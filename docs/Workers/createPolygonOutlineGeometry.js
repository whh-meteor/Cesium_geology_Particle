/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.118.1
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a}from"./chunk-Q7FDDGQE.js";import{a as b}from"./chunk-EQCQ5LRI.js";import{a as W}from"./chunk-CRFMECNE.js";import{a as V}from"./chunk-7JCIFY66.js";import"./chunk-ED2EM7ZX.js";import"./chunk-YZP3DYN3.js";import{a as D}from"./chunk-WLRVP2UA.js";import{a as F}from"./chunk-TLL4Q2KI.js";import"./chunk-4IWHN7T4.js";import{a as j,b as k}from"./chunk-LKPDAB55.js";import"./chunk-CIEXTRKV.js";import"./chunk-OSVMDAN4.js";import"./chunk-PT2EMSIG.js";import"./chunk-REUYHR24.js";import{a as M}from"./chunk-RQXB4B4V.js";import{a as B}from"./chunk-MPVEZNKB.js";import{b as U,c as C,d as S}from"./chunk-FATK2EQ2.js";import{d as z}from"./chunk-3FEM743H.js";import"./chunk-CMXCDAKR.js";import{a as w}from"./chunk-77ESX6BV.js";import{a as v,d as y}from"./chunk-LJCGAQ64.js";import{a as T}from"./chunk-JFG572S7.js";import"./chunk-JZYZ7RT4.js";import"./chunk-IRDBGNMC.js";import{a as P}from"./chunk-42NIXFVW.js";import{a as G,b as A}from"./chunk-5YVCOCPP.js";import{e as O}from"./chunk-U73D6PDD.js";var Y=[],R=[];function K(e,t,i,r,o){let n=F.fromPoints(t,e).projectPointsOntoPlane(t,Y);k.computeWindingOrder2D(n)===j.CLOCKWISE&&(n.reverse(),t=t.slice().reverse());let s,p,u=t.length,l=0;if(r)for(s=new Float64Array(2*u*3),p=0;p<u;p++){let e=t[p],i=t[(p+1)%u];s[l++]=e.x,s[l++]=e.y,s[l++]=e.z,s[l++]=i.x,s[l++]=i.y,s[l++]=i.z}else{let r=0;if(o===b.GEODESIC)for(p=0;p<u;p++)r+=a.subdivideLineCount(t[p],t[(p+1)%u],i);else if(o===b.RHUMB)for(p=0;p<u;p++)r+=a.subdivideRhumbLineCount(e,t[p],t[(p+1)%u],i);for(s=new Float64Array(3*r),p=0;p<u;p++){let r;o===b.GEODESIC?r=a.subdivideLine(t[p],t[(p+1)%u],i,R):o===b.RHUMB&&(r=a.subdivideRhumbLine(e,t[p],t[(p+1)%u],i,R));let n=r.length;for(let e=0;e<n;++e)s[l++]=r[e]}}u=s.length/3;let h=2*u,c=M.createTypedArray(u,h);for(l=0,p=0;p<u-1;p++)c[l++]=p,c[l++]=p+1;return c[l++]=u-1,c[l++]=0,new W({geometry:new C({attributes:new B({position:new S({componentDatatype:w.DOUBLE,componentsPerAttribute:3,values:s})}),indices:c,primitiveType:U.LINES})})}function q(e,t,i,r,o){let n=F.fromPoints(t,e).projectPointsOntoPlane(t,Y);k.computeWindingOrder2D(n)===j.CLOCKWISE&&(n.reverse(),t=t.slice().reverse());let s,p,u=t.length,l=new Array(u),h=0;if(r)for(s=new Float64Array(2*u*3*2),p=0;p<u;++p){l[p]=h/3;let e=t[p],i=t[(p+1)%u];s[h++]=e.x,s[h++]=e.y,s[h++]=e.z,s[h++]=i.x,s[h++]=i.y,s[h++]=i.z}else{let r=0;if(o===b.GEODESIC)for(p=0;p<u;p++)r+=a.subdivideLineCount(t[p],t[(p+1)%u],i);else if(o===b.RHUMB)for(p=0;p<u;p++)r+=a.subdivideRhumbLineCount(e,t[p],t[(p+1)%u],i);for(s=new Float64Array(3*r*2),p=0;p<u;++p){let r;l[p]=h/3,o===b.GEODESIC?r=a.subdivideLine(t[p],t[(p+1)%u],i,R):o===b.RHUMB&&(r=a.subdivideRhumbLine(e,t[p],t[(p+1)%u],i,R));let n=r.length;for(let e=0;e<n;++e)s[h++]=r[e]}}u=s.length/6;let c=l.length,y=2*(2*u+c),f=M.createTypedArray(u+c,y);for(h=0,p=0;p<u;++p)f[h++]=p,f[h++]=(p+1)%u,f[h++]=p+u,f[h++]=(p+1)%u+u;for(p=0;p<c;p++){let e=l[p];f[h++]=e,f[h++]=e+u}return new W({geometry:new C({attributes:new B({position:new S({componentDatatype:w.DOUBLE,componentsPerAttribute:3,values:s})}),indices:f,primitiveType:U.LINES})})}function L(e){if(A.typeOf.object("options",e),A.typeOf.object("options.polygonHierarchy",e.polygonHierarchy),e.perPositionHeight&&O(e.height))throw new G("Cannot use both options.perPositionHeight and options.height");if(O(e.arcType)&&e.arcType!==b.GEODESIC&&e.arcType!==b.RHUMB)throw new G("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let t=e.polygonHierarchy,i=P(e.ellipsoid,y.WGS84),r=P(e.granularity,T.RADIANS_PER_DEGREE),o=P(e.perPositionHeight,!1),n=o&&O(e.extrudedHeight),s=P(e.arcType,b.GEODESIC),p=P(e.height,0),u=P(e.extrudedHeight,p);if(!n){let e=Math.max(p,u);u=Math.min(p,u),p=e}this._ellipsoid=y.clone(i),this._granularity=r,this._height=p,this._extrudedHeight=u,this._arcType=s,this._polygonHierarchy=t,this._perPositionHeight=o,this._perPositionHeightExtrude=n,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=a.computeHierarchyPackedLength(t,v)+y.packedLength+8}L.pack=function(e,t,i){return A.typeOf.object("value",e),A.defined("array",t),i=P(i,0),i=a.packPolygonHierarchy(e._polygonHierarchy,t,i,v),y.pack(e._ellipsoid,t,i),i+=y.packedLength,t[i++]=e._height,t[i++]=e._extrudedHeight,t[i++]=e._granularity,t[i++]=e._perPositionHeightExtrude?1:0,t[i++]=e._perPositionHeight?1:0,t[i++]=e._arcType,t[i++]=P(e._offsetAttribute,-1),t[i]=e.packedLength,t};var J=y.clone(y.UNIT_SPHERE),Q={polygonHierarchy:{}};L.unpack=function(e,t,i){A.defined("array",e),t=P(t,0);let r=a.unpackPolygonHierarchy(e,t,v);t=r.startingIndex,delete r.startingIndex;let o=y.unpack(e,t,J);t+=y.packedLength;let n=e[t++],s=e[t++],p=e[t++],u=1===e[t++],l=1===e[t++],h=e[t++],c=e[t++],f=e[t];return O(i)||(i=new L(Q)),i._polygonHierarchy=r,i._ellipsoid=y.clone(o,i._ellipsoid),i._height=n,i._extrudedHeight=s,i._granularity=p,i._perPositionHeight=l,i._perPositionHeightExtrude=u,i._arcType=h,i._offsetAttribute=-1===c?void 0:c,i.packedLength=f,i},L.fromPositions=function(e){e=P(e,P.EMPTY_OBJECT),A.defined("options.positions",e.positions);let t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute};return new L(t)},L.createGeometry=function(e){let t=e._ellipsoid,i=e._granularity,r=e._polygonHierarchy,o=e._perPositionHeight,n=e._arcType,s=a.polygonOutlinesFromHierarchy(r,!o,t);if(0===s.length)return;let p,u,l,h=[],c=T.chordLength(i,t.maximumRadius),y=e._height,f=e._extrudedHeight,d=e._perPositionHeightExtrude||!T.equalsEpsilon(y,f,0,T.EPSILON2);if(d)for(l=0;l<s.length;l++){if(p=q(t,s[l],c,o,n),p.geometry=a.scaleToGeodeticHeightExtruded(p.geometry,y,f,t,o),O(e._offsetAttribute)){let t=p.geometry.attributes.position.values.length/3,i=new Uint8Array(t);e._offsetAttribute===D.TOP?i=i.fill(1,0,t/2):(u=e._offsetAttribute===D.NONE?0:1,i=i.fill(u)),p.geometry.attributes.applyOffset=new S({componentDatatype:w.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(p)}else for(l=0;l<s.length;l++){if(p=K(t,s[l],c,o,n),p.geometry.attributes.position.values=k.scaleToGeodeticHeight(p.geometry.attributes.position.values,y,t,!o),O(e._offsetAttribute)){let t=p.geometry.attributes.position.values.length;u=e._offsetAttribute===D.NONE?0:1;let i=new Uint8Array(t/3).fill(u);p.geometry.attributes.applyOffset=new S({componentDatatype:w.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(p)}let m=V.combineInstances(h)[0],g=z.fromVertices(m.attributes.position.values);return new C({attributes:m.attributes,indices:m.indices,primitiveType:m.primitiveType,boundingSphere:g,offsetAttribute:e._offsetAttribute})};var x=L;function X(e,t){return O(t)&&(e=x.unpack(e,t)),e._ellipsoid=y.clone(e._ellipsoid),x.createGeometry(e)}var Oe=X;export{Oe as default};