/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.118.1
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as Gt,b as Xt}from"./chunk-XXATY55N.js";import{a as kt}from"./chunk-4FSMRIBR.js";import{a as lt}from"./chunk-7RBDS4IP.js";import{a as Dt}from"./chunk-K62YE2WO.js";import"./chunk-ED2EM7ZX.js";import"./chunk-TLL4Q2KI.js";import{a as qt}from"./chunk-4IWHN7T4.js";import"./chunk-PT2EMSIG.js";import"./chunk-REUYHR24.js";import{d as Lt}from"./chunk-3FEM743H.js";import{b as $,g as Ot,h as zt}from"./chunk-CMXCDAKR.js";import"./chunk-77ESX6BV.js";import{a as P,b as N,c as wt,d as Ht}from"./chunk-LJCGAQ64.js";import{a as r}from"./chunk-JFG572S7.js";import"./chunk-JZYZ7RT4.js";import{a as Vt}from"./chunk-IRDBGNMC.js";import{a as Ut}from"./chunk-42NIXFVW.js";import"./chunk-5YVCOCPP.js";import{e as ht}from"./chunk-U73D6PDD.js";var te=Uint16Array.BYTES_PER_ELEMENT,mt=Int32Array.BYTES_PER_ELEMENT,Pt=Uint32Array.BYTES_PER_ELEMENT,ee=Float32Array.BYTES_PER_ELEMENT,H=Float64Array.BYTES_PER_ELEMENT;function tt(t,e,n){n=Ut(n,r);let i=t.length;for(let o=0;o<i;++o)if(n.equalsEpsilon(t[o],e,r.EPSILON12))return o;return-1}function oe(t,e){t.ellipsoid=Ht.clone(t.ellipsoid),t.rectangle=zt.clone(t.rectangle);let n=se(t.buffer,t.relativeToCenter,t.ellipsoid,t.rectangle,t.nativeRectangle,t.exaggeration,t.exaggerationRelativeHeight,t.skirtHeight,t.includeWebMercatorT,t.negativeAltitudeExponentBias,t.negativeElevationThreshold),i=n.vertices;e.push(i.buffer);let r=n.indices;return e.push(r.buffer),{vertices:i.buffer,indices:r.buffer,numberOfAttributes:n.encoding.stride,minimumHeight:n.minimumHeight,maximumHeight:n.maximumHeight,boundingSphere3D:n.boundingSphere3D,orientedBoundingBox:n.orientedBoundingBox,occludeePointInScaledSpace:n.occludeePointInScaledSpace,encoding:n.encoding,vertexCountWithoutSkirts:n.vertexCountWithoutSkirts,indexCountWithoutSkirts:n.indexCountWithoutSkirts,westIndicesSouthToNorth:n.westIndicesSouthToNorth,southIndicesEastToWest:n.southIndicesEastToWest,eastIndicesNorthToSouth:n.eastIndicesNorthToSouth,northIndicesWestToEast:n.northIndicesWestToEast}}var u=new N,G=new P,ne=new P,ie=new P,re=new $;function se(t,e,n,i,o,a,s,l,h,c,d){let m,g,p,I,E,f;ht(i)?(m=i.west,g=i.south,p=i.east,I=i.north,E=i.width,f=i.height):(m=r.toRadians(o.west),g=r.toRadians(o.south),p=r.toRadians(o.east),I=r.toRadians(o.north),E=r.toRadians(i.width),f=r.toRadians(i.height));let T,S,x=[g,I],w=[m,p],R=Ot.eastNorthUpToFixedFrame(e,n),k=$.inverseTransformation(R,re);h&&(T=lt.geodeticLatitudeToMercatorAngle(g),S=1/(lt.geodeticLatitudeToMercatorAngle(I)-T));let A=1!==a,b=new DataView(t),M=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY,B=ne;B.x=Number.POSITIVE_INFINITY,B.y=Number.POSITIVE_INFINITY,B.z=Number.POSITIVE_INFINITY;let F=ie;F.x=Number.NEGATIVE_INFINITY,F.y=Number.NEGATIVE_INFINITY,F.z=Number.NEGATIVE_INFINITY;let v,_,C=0,j=0,W=0;for(_=0;_<4;++_){let t=C;v=b.getUint32(t,!0),t+=Pt;let e=r.toRadians(180*b.getFloat64(t,!0));t+=H,-1===tt(w,e)&&w.push(e);let n=r.toRadians(180*b.getFloat64(t,!0));t+=H,-1===tt(x,n)&&x.push(n),t+=2*H;let i=b.getInt32(t,!0);t+=mt,j+=i,i=b.getInt32(t,!0),W+=3*i,C+=v+Pt}let Y=[],U=[],V=new Array(j),L=new Array(j),O=new Array(j),D=h?new Array(j):[],X=A?new Array(j):[],z=new Array(W),q=[],J=[],K=[],Z=[],Q=0,et=0;for(C=0,_=0;_<4;++_){v=b.getUint32(C,!0),C+=Pt;let t=C,e=r.toRadians(180*b.getFloat64(C,!0));C+=H;let i=r.toRadians(180*b.getFloat64(C,!0));C+=H;let o=r.toRadians(180*b.getFloat64(C,!0)),a=.5*o;C+=H;let s=r.toRadians(180*b.getFloat64(C,!0)),l=.5*s;C+=H;let E=b.getInt32(C,!0);C+=mt;let f=b.getInt32(C,!0);C+=mt,C+=mt;let R=new Array(E);for(let H=0;H<E;++H){let t=e+b.getUint8(C++)*o;u.longitude=t;let E=i+b.getUint8(C++)*s;u.latitude=E;let f=b.getFloat32(C,!0);if(C+=ee,0!==f&&f<d&&(f*=-Math.pow(2,c)),f*=6371010,u.height=f,-1!==tt(w,t)||-1!==tt(x,E)){let t=tt(Y,u,N);if(-1!==t){R[H]=U[t];continue}Y.push(N.clone(u)),U.push(Q)}R[H]=Q,Math.abs(t-m)<a?q.push({index:Q,cartographic:N.clone(u)}):Math.abs(t-p)<a?K.push({index:Q,cartographic:N.clone(u)}):Math.abs(E-g)<l?J.push({index:Q,cartographic:N.clone(u)}):Math.abs(E-I)<l&&Z.push({index:Q,cartographic:N.clone(u)}),M=Math.min(f,M),y=Math.max(f,y),O[Q]=f;let v=n.cartographicToCartesian(u);if(V[Q]=v,h&&(D[Q]=(lt.geodeticLatitudeToMercatorAngle(E)-T)*S),A){let t=n.geodeticSurfaceNormal(v);X[Q]=t}$.multiplyByPoint(k,v,G),P.minimumByComponent(G,B,B),P.maximumByComponent(G,F,F);let _=(t-m)/(p-m);_=r.clamp(_,0,1);let j=(E-g)/(I-g);j=r.clamp(j,0,1),L[Q]=new wt(_,j),++Q}let _=3*f;for(let n=0;n<_;++n,++et)z[et]=R[b.getUint16(C,!0)],C+=te;if(v!==C-t)throw new Vt("Invalid terrain tile.")}V.length=Q,L.length=Q,O.length=Q,h&&(D.length=Q),A&&(X.length=Q);let nt=Q,it=et,rt={hMin:M,lastBorderPoint:void 0,skirtHeight:l,toENU:k,ellipsoid:n,minimum:B,maximum:F};q.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),J.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),K.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),Z.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));let ot=1e-5;if(gt(V,O,L,D,X,z,rt,q,-ot*E,!0,-ot*f),gt(V,O,L,D,X,z,rt,J,-ot*f,!1),gt(V,O,L,D,X,z,rt,K,ot*E,!0,ot*f),gt(V,O,L,D,X,z,rt,Z,ot*f,!1),q.length>0&&Z.length>0){let t=q[0].index,e=nt,n=Z[Z.length-1].index,i=V.length-1;z.push(n,i,e,e,t,n)}j=V.length;let at,ut=Lt.fromPoints(V);ht(i)&&(at=Dt.fromRectangle(i,M,y,n));let st=new Gt(n).computeHorizonCullingPointPossiblyUnderEllipsoid(e,V,M),ct=new qt(B,F,e),dt=new Xt(e,ct,rt.hMin,y,R,!1,h,A,a,s),pt=new Float32Array(j*dt.stride),It=0;for(let r=0;r<j;++r)It=dt.encode(pt,It,V[r],L[r],O[r],void 0,D[r],X[r]);let Et=q.map((function(t){return t.index})).reverse(),ft=J.map((function(t){return t.index})).reverse(),Nt=K.map((function(t){return t.index})).reverse(),Tt=Z.map((function(t){return t.index})).reverse();return ft.unshift(Nt[Nt.length-1]),ft.push(Et[0]),Tt.unshift(Et[Et.length-1]),Tt.push(Nt[0]),{vertices:pt,indices:new Uint16Array(z),maximumHeight:y,minimumHeight:M,encoding:dt,boundingSphere3D:ut,orientedBoundingBox:at,occludeePointInScaledSpace:st,vertexCountWithoutSkirts:nt,indexCountWithoutSkirts:it,westIndicesSouthToNorth:Et,southIndicesEastToWest:ft,eastIndicesNorthToSouth:Nt,northIndicesWestToEast:Tt}}function gt(t,e,n,i,o,a,s,l,h,c,d){let m=l.length;for(let g=0;g<m;++g){let p=l[g],I=p.cartographic,E=p.index,f=t.length,T=I.longitude,S=I.latitude;S=r.clamp(S,-r.PI_OVER_TWO,r.PI_OVER_TWO);let x=I.height-s.skirtHeight;s.hMin=Math.min(s.hMin,x),N.fromRadians(T,S,x,u),c&&(u.longitude+=h),c?g===m-1?u.latitude+=d:0===g&&(u.latitude-=d):u.latitude+=h;let w=s.ellipsoid.cartographicToCartesian(u);t.push(w),e.push(x),n.push(wt.clone(n[E])),i.length>0&&i.push(i[E]),o.length>0&&o.push(o[E]),$.multiplyByPoint(s.toENU,w,G);let R=s.minimum,k=s.maximum;P.minimumByComponent(G,R,R),P.maximumByComponent(G,k,k);let A=s.lastBorderPoint;if(ht(A)){let t=A.index;a.push(t,f-1,f,f,E,t)}s.lastBorderPoint=p}}var Ae=kt(oe);export{Ae as default};